actionButton("decrement", "Back"),
actionButton("increment", "Next")
))
}
})
# The observers re-run the code whenever the button is clicked
# Use isolate to avoid getting stuck in an infinite loop
observe({
input$increment
values$i <- isolate(values$i) + 1
})
observe({
input$decrement
isolate(values$i <- values$i - 1)
})
}
# run ui and server together
runApp(list(ui = ui, server = server))
ui <- basicPage(
uiOutput("buttons")
,
uiOutput("count")
)
server <- function(input, output) {
# A reactiveValues object holds the value of the counter
values <- reactiveValues(i = 0)
# Print the value of the counter stored in values$i
output$count <- renderUI({
h4(paste0("counter = ", values$i))
})
# Display buttons in the mainPanel
output$buttons <- renderUI({
if (values$i == 0) {
return(list(actionButton("increment0", "Next")))
} else {
return(list(
actionButton("decrement", "Back"),
actionButton("increment", "Next")
))
}
})
# The observers re-run the code whenever the button is clicked
# Use isolate to avoid getting stuck in an infinite loop
observe({
input$increment; input$increment0
values$i <- isolate(values$i) + 1
})
observe({
input$decrement
isolate(values$i <- values$i - 1)
})
}
# run ui and server together
runApp(list(ui = ui, server = server))
ui <- basicPage(
uiOutput("buttons")
,
uiOutput("count")
)
server <- function(input, output) {
# A reactiveValues object holds the value of the counter
values <- reactiveValues(i = 0)
# Print the value of the counter stored in values$i
output$count <- renderUI({
h4(paste0("counter = ", values$i))
})
# Display buttons in the mainPanel
output$buttons <- renderUI({
if (values$i == 0) {
return(list(actionButton("increment", "Next")))
} else {
return(list(
actionButton("decrement", "Back"),
actionButton("increment", "Next")
))
}
})
# The observers re-run the code whenever the button is clicked
# Use isolate to avoid getting stuck in an infinite loop
observe({
if(input$increment>0)  values$i <- isolate(values$i) + 1
})
observe({
input$decrement
isolate(values$i <- values$i - 1)
})
}
# run ui and server together
runApp(list(ui = ui, server = server))
ui <- basicPage(
uiOutput("buttons")
,
uiOutput("count")
)
server <- function(input, output) {
# A reactiveValues object holds the value of the counter
values <- reactiveValues(i = 0)
# Print the value of the counter stored in values$i
output$count <- renderUI({
h4(paste0("counter = ", values$i))
})
# Display buttons in the mainPanel
output$buttons <- renderUI({
if (values$i == 0) {
return(list(actionButton("increment", "Next")))
} else {
return(list(
actionButton("decrement", "Back"),
actionButton("increment", "Next")
))
}
})
# The observers re-run the code whenever the button is clicked
# Use isolate to avoid getting stuck in an infinite loop
observe({
if(!is.null(input$increment) && input$increment>0)  values$i <- isolate(values$i) + 1
})
observe({
input$decrement
isolate(values$i <- values$i - 1)
})
}
# run ui and server together
runApp(list(ui = ui, server = server))
rm(list=ls())
ui <- basicPage(
uiOutput("buttons")
,
uiOutput("count")
)
server <- function(input, output) {
# A reactiveValues object holds the value of the counter
values <- reactiveValues(i = 0)
# Print the value of the counter stored in values$i
output$count <- renderUI({
h4(paste0("counter = ", values$i))
})
# Display buttons in the mainPanel
output$buttons <- renderUI({
if (values$i == 0) {
return(list(actionButton("increment", "Next")))
} else {
return(list(
actionButton("decrement", "Back"),
actionButton("increment", "Next")
))
}
})
# The observers re-run the code whenever the button is clicked
# Use isolate to avoid getting stuck in an infinite loop
observe({
if(!is.null(input$increment) && input$increment>0)  values$i <- isolate(values$i) + 1
})
observe({
input$decrement
isolate(values$i <- values$i - 1)
})
}
# run ui and server together
runApp(list(ui = ui, server = server))
ui <- basicPage(
uiOutput("buttons")
,
uiOutput("count")
)
server <- function(input, output) {
# A reactiveValues object holds the value of the counter
values <- reactiveValues(i = 0)
# Print the value of the counter stored in values$i
output$count <- renderUI({
h4(paste0("counter = ", values$i))
})
# Display buttons in the mainPanel
output$buttons <- renderUI({
if (values$i == 0) {
return(list(actionButton("increment", "Next")))
} else {
return(list(
actionButton("decrement", "Back"),
actionButton("increment", "Next")
))
}
})
# The observers re-run the code whenever the button is clicked
# Use isolate to avoid getting stuck in an infinite loop
observe({
if(!is.null(input$increment) && input$increment>0)  values$i <- isolate(values$i) + 1
})
observe({
if(!is.null(input$decrement) && input$decrement>0) isolate(values$i <- values$i - 1)
})
}
# run ui and server together
runApp(list(ui = ui, server = server))
install.packages("Matrix")
library(rcdd)
library(gmp) # voir les updates (as.numeric ou je ne sais plus..)
## auxiliary function ##
asab <- function(x) as.character(as.bigq(x))
joinings <- function(p.rows, p.cols, row.names=1:length(p.rows), col.names=1:length(p.cols)){
if(length(p.rows)>1){
if(length(p.cols)>1){
B <- c(p.rows,p.cols)
}else{ B <- p.rows }
}else{ B <- p.cols }
m <- length(p.rows)
n <- length(p.cols)
if(m>1){ M1 <- t(model.matrix(~0+gl(m,n)))[,] }else{ M1 <- NULL }
if(n>1){ M2 <- t(model.matrix(~0+factor(rep(1:n,m))))[,] }else{ M2 <- NULL }
M <- rbind(M1,M2)
mH0 <- makeH(a1=asab(-diag(m*n)), b1=asab(rep(0,m*n)), a2=asab(M), b2=asab(B))
extremals <- scdd(mH0)$output[,-c(1,2)]
if(is.null(dim(extremals))) extremals <- matrix(extremals, nrow=1)
extremals <- lapply(1:nrow(extremals), function(i) matrix(extremals[i,], ncol=n, byrow=TRUE) )
lapply(extremals,
function(M){
rownames(M) <- row.names
colnames(M) <- col.names
return(M)
})
#  t(q2d(scdd(mH0)$output[,-c(1,2)]))
}
## matrice de dissimilarités ###
dist.mat <- function(A, rho){
m <- length(A)
out <- as.bigq(matrix(0, nrow=m, ncol=m))
for(j in 1:(m-1)){
for(i in (j+1):m){
out[i,j] <- out[j,i] <- rho(A[i],A[j])
}
}
#s <- matrix(NA, nrow=m, ncol=m)
# Out <- as.bigq(s)
#Out[lower.tri(s, diag=TRUE)] <- out[lower.tri(s, diag=TRUE)]
#Out[lower.tri(Out)] <- out[lower.tri(Out, diag=TRUE)]
#rownames(out) <- as.character(A)
#as.matrix(as.dist(Out))
out
}
## kantorovich ##
kantorovich <- function(mu, nu, A, Rho, which.mu=A, which.nu=A){
if(length(mu)>1 | length(nu) >1){
tests <- joinings(mu, nu, row.names=A[which.mu], col.names=A[which.nu])
}else{tests <- list(as.bigq(1)) }
n.tests <- length(tests)
distances <- as.bigq(rep(NA, n.tests))
for(i in 1:n.tests){
distances[i] <- sum(as.bigq(Rho[which.mu,which.nu])*tests[[i]])
}
out <- list(joinings=tests, distances=distances)
return(out)
}
pascal.Mn <- function(n){ # attention sortie numérique maintenant
n <- n-1
M <- matrix(0, nrow=n+2, ncol=n+3)
for(i in 1:(n+2)){
M[i,][c(i,i+1)] <- 1
}
rownames(M) <- 1:(n+2)
colnames(M) <- 1:(n+3)
M
}
vershik <- function(Mn.fun, N){ #Mn = pascal.Mn for instance
############# FIRST STEP #################
L <- Probs <- Supp <- Tau <- Dims <- vector("list", N)
# initialisation
k <- 0
M <- Mn.fun(k)
m <- nrow(M)-> Tau[[k+1]]
n <- ncol(M)
dims0 <- Dims[[k+1]] <-  as.vector(as.bigz(M))
#L0 <- as.bigq(rep(1,m))
#Mu0 <- L0/m
S <- Supp[[k+1]] <- lapply(1:n, function(i) which(M[,i] != 0))
Probs[[k+1]] <-lapply(dims0, function(x) as.character(x))
invisible(Vectorize(function(i) names(Probs[[k+1]][[i]]) <<- S[[i]])(1:n)) # "déconne" avec gmp... -> mettre en character
for(k in 1:N){
M <- Mn.fun(k)
m <- nrow(M) -> Tau[[k+1]]
n <- ncol(M)
S <- Supp[[k+1]] <- apply(M, 2, function(x) which(x!=0)) # lapply(1:n, function(i) which(M[,i] != 0))
dims <- Dims[[k+1]] <-  as.vector(dims0%*%M) # apply(as.bigz(t(M)), 2, function(x) tcrossprod(x,dims0)) # apply(M, 2, function(x) tcrossprod(x,dims0))
Probs[[k+1]] <- lapply(1:n, # probas non normalis\'es
function(i){
as.character(dims0[S[[i]]]/dims[i])
})
invisible(Vectorize(function(i) names(Probs[[k+1]][[i]]) <<- S[[i]])(1:n))
dims0 <- dims
}
############### SECOND STEP ###############
RHO <- JO <- BJO <-  vector("list", N) # jo joinings
### initialization ###
k <- 1
m <- Tau[[k]]
n <- Tau[[k+1]]
Rho <- as.bigq(matrix(1, nrow=n, ncol=n)) - diag(1,n)
#diag(Rho) <- 0 marche pas avec gmp
RHO[[k]] <- Rho
#
for(k in 2:N){
laws <- list(
probs = Probs[[k]],
support = Supp[[k]]
)
m <- Tau[[k]]
n <- Tau[[k+1]]
Rho <- as.bigq(matrix(0, nrow=n, ncol=n))
# matrice triangulaire pour gérer le stockage dans JO
T <- matrix(NA, nrow=n, ncol=n)
T[upper.tri(T, diag=FALSE)] <- 1:(n*(n-1)/2)
T <- t(T)
JO[[k]] <- BJO[[k]] <- vector("list", n*(n-1)/2)
for(j in 1:(n-1)){
nu <- laws$probs[[j]]
which.nu <- laws$support[[j]]
for(i in (j+1):n){
ij <- T[i,j]
names(JO[[k]])[ij] <- names(BJO[[k]])[ij] <-paste0("rho(",i,",",j,")")
mu <- laws$probs[[i]]
which.mu <- laws$support[[i]]
K <- kantorovich(mu, nu, 1:m, RHO[[k-1]], which.mu, which.nu)
dists <- K$distances
Rho[i,j] <- Rho[j,i] <- mindist <- min(dists)
bests <- which(dists==mindist)
JO[[k]][[ij]] <- K$joinings
BJO[[k]][[ij]] <- K$joinings[bests]
}
}
RHO[[k]] <- Rho
}
out <- list(RHO=RHO,  JO=JO, BJO=BJO, Probs=Probs, Supp=Supp, Dims=Dims)
return(out)
}
Euler.Mn <- function(n){
n <- n-1
M <- matrix(0, nrow=n+2, ncol=n+3)
for(i in 1:(n+2)){
M[i,][c(i,i+1)] <- c(i,n+3-i)
}
rownames(M) <- 1:(n+2)
colnames(M) <- 1:(n+3)
M
}
vershik(Euler.Mn, 3)
vershik <- function(Mn.fun, N){ #Mn = pascal.Mn for instance
############# FIRST STEP #################
L <- Probs <- Supp <- Tau <- Dims <- vector("list", N)
# initialisation
k <- 0
M <- Mn.fun(k)
m <- nrow(M)-> Tau[[k+1]]
n <- ncol(M)
dims0 <- Dims[[k+1]] <-  as.vector(as.bigz(M))
#L0 <- as.bigq(rep(1,m))
#Mu0 <- L0/m
S <- Supp[[k+1]] <- lapply(1:n, function(i) which(M[,i] != 0))
Probs[[k+1]] <-lapply(dims0, function(x) as.character(x))
invisible(Vectorize(function(i) names(Probs[[k+1]][[i]]) <<- S[[i]])(1:n)) # "déconne" avec gmp... -> mettre en character
for(k in 1:N){
M <- Mn.fun(k)
m <- nrow(M) -> Tau[[k+1]]
n <- ncol(M)
S <- Supp[[k+1]] <- apply(M, 2, function(x) which(x!=0)) # lapply(1:n, function(i) which(M[,i] != 0))
dims <- Dims[[k+1]] <-  as.vector(dims0%*%M) # apply(as.bigz(t(M)), 2, function(x) tcrossprod(x,dims0)) # apply(M, 2, function(x) tcrossprod(x,dims0))
Probs[[k+1]] <- lapply(1:n, # probas non normalis\'es
function(i){
as.character(dims0[S[[i]]]*M[S[[i]],i]/dims[i])
})
invisible(Vectorize(function(i) names(Probs[[k+1]][[i]]) <<- S[[i]])(1:n))
dims0 <- dims
}
############### SECOND STEP ###############
RHO <- JO <- BJO <-  vector("list", N) # jo joinings
### initialization ###
k <- 1
m <- Tau[[k]]
n <- Tau[[k+1]]
Rho <- as.bigq(matrix(1, nrow=n, ncol=n)) - diag(1,n)
#diag(Rho) <- 0 marche pas avec gmp
RHO[[k]] <- Rho
#
for(k in 2:N){
laws <- list(
probs = Probs[[k]],
support = Supp[[k]]
)
m <- Tau[[k]]
n <- Tau[[k+1]]
Rho <- as.bigq(matrix(0, nrow=n, ncol=n))
# matrice triangulaire pour gérer le stockage dans JO
T <- matrix(NA, nrow=n, ncol=n)
T[upper.tri(T, diag=FALSE)] <- 1:(n*(n-1)/2)
T <- t(T)
JO[[k]] <- BJO[[k]] <- vector("list", n*(n-1)/2)
for(j in 1:(n-1)){
nu <- laws$probs[[j]]
which.nu <- laws$support[[j]]
for(i in (j+1):n){
ij <- T[i,j]
names(JO[[k]])[ij] <- names(BJO[[k]])[ij] <-paste0("rho(",i,",",j,")")
mu <- laws$probs[[i]]
which.mu <- laws$support[[i]]
K <- kantorovich(mu, nu, 1:m, RHO[[k-1]], which.mu, which.nu)
dists <- K$distances
Rho[i,j] <- Rho[j,i] <- mindist <- min(dists)
bests <- which(dists==mindist)
JO[[k]][[ij]] <- K$joinings
BJO[[k]][[ij]] <- K$joinings[bests]
}
}
RHO[[k]] <- Rho
}
out <- list(RHO=RHO,  JO=JO, BJO=BJO, Probs=Probs, Supp=Supp, Dims=Dims)
return(out)
}
vershik(Euler.Mn, 3)
vershik(Euler.Mn, 4)
help(pa=diagram)
library(diagram)
pos <- coordinates(pos = 4, my = 0.2)
text(pos, LETTERS[1:4], cex = 2)
for (i in 1:3)
curvedarrow(from = pos[1, ] + c(0,-0.05), to = pos[i+1, ] + c(0,-0.05),
curve = 0.5, arr.pos = 1)
openplotmat(main = "curvedarrow")
pos <- coordinates(pos = 4, my = 0.2)
text(pos, LETTERS[1:4], cex = 2)
for (i in 1:3)
curvedarrow(from = pos[1, ] + c(0,-0.05), to = pos[i+1, ] + c(0,-0.05),
curve = 0.5, arr.pos = 1)
curvedarrow(from = pos[1, ] + c(0,-0.05), to = pos[i+1, ] + c(0,-0.05),
+                 curve = c(0.1,0.25), arr.pos = 1)
curvedarrow(from = pos[1, ] + c(0,-0.05), to = pos[i+1, ] + c(0,-0.05),
+                 curve = 0.1, arr.pos = 1)
curvedarrow(from = pos[1, ] + c(0,-0.05), to = pos[i+1, ] + c(0,-0.05),
curve = c(0.1,0.25), arr.pos = 1)
11*410/17
help(pa=rgl)
wd <- "C:\\Users\\User\\Pictures\\CyberShot\\10-01-2014\\"
# the folder containing the figures :
fig.path <- wd
# all JPG figures :
figures <- list.files(fig.path, pattern=".JPG", all.files=TRUE)
# resize all figures
for(i in 1:length(figures)){
infile <- paste0(wd,figures[i])
out <-   paste0(wd,"compressed_", figures[i])
comm <- paste("convert -strip -interlace Plane -gaussian-blur 0.05 -quality 30%", infile, out)
shell(comm)
}
wd <- "C:\\Users\\User\\Pictures\\CyberShot\\13-01-2014\\"
# the folder containing the figures :
fig.path <- wd
# all JPG figures :
figures <- list.files(fig.path, pattern=".JPG", all.files=TRUE)
# resize all figures
for(i in 1:length(figures)){
infile <- paste0(wd,figures[i])
out <-   paste0(wd,"compressed_", figures[i])
comm <- paste("convert -strip -interlace Plane -gaussian-blur 0.05 -quality 30%", infile, out)
shell(comm)
}
install.packages("gWidgets2")
install.packages("gWidgets2RGtk2")
install.packages("gtools")
gsub("\\1", "\\1", "This \ntest")
gsub("*", "\\1", "This \ntest")
gsub("a","b","ab")
gsub("*", "\\\\1", "This \ntest")
gsub("*", "\\\\", "This \ntest")
gsub("*", "\\", "This \ntest")
gsub("\t", "\\\\t", "c:\test")
gsub("\*", "\\\\*", "c:\test")
gsub("\1", "\\\\1", "c:\test")
gsub("\+", "\\\\+", "c:\test")
gsub("\\+", "\\\\+", "c:\test")
gsub("\\+", "\\\\+", "c:\test", perl=TRUE)
gsub("\\*", "\\\\+", "c:\test", perl=TRUE)
gsub("\\[*]", "\\\\+", "c:\test", perl=TRUE)
gsub("\\[*]", "\\\\", "c:\test", perl=TRUE)
gsub("\", "\\\\", "c:\test")
gsub("\", "\\\\", "c:\test", fixed=TRUE)
gsub("\\", "\\\\", "c:\test", fixed=TRUE)
?gsub
?regex
library(stringr)
str.replace("abc", "a", "b")
str_replace("abc", "a", "b")
str_replace("\bc", "\", "\\")
str_replace("\bc", "\\", "\\\\")
?str_replace
str_replace("\bc", "\\", "2")
str_replace("\bc", "\", "2")
str_replace("\bc", "\\\\", "2")
setwd( "D:/Github/stlapblog")
library(poirot)
blogify(".")
setwd( "D:/Github/stlapblog")
library(poirot)
blogify(".")
setwd( "D:/Github/stlapblog")
library(poirot)
blogify(".")
setwd( "D:/Github/stlapblog")
library(poirot)
blogify(".")
setwd( "D:/Github/stlapblog")
library(poirot)
blogify(".")
setwd( "D:/Github/stlapblog")
library(poirot)
blogify(".")
