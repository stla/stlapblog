---
title: "Drawing a Bratteli graph"
author: "Stéphane Laurent"
date: "14/08/2015"
output:
  html_document:
    keep_md: yes
---


```{r setup, include=FALSE}
# TO DO : BLACKPATH DONNÉ PAR LABEL DES EDGES, PAS DES VERTICES
library(knitr)
opts_chunk$set(fig.path="Figures/bratteli-")
knit_hooks$set(plot = function(x, options) {
  paste('<figure><img style="display: block;margin-left: auto;margin-right: auto;" width=400 src="',
        opts_knit$get('base.url'), paste(x, collapse = '.'),
        '"><figcaption style=\"text-align: center; line-height:21px; font-weight:normal; font-family:times; font-size:18px; font-style:italic\">', 
        options$fig.cap, '</figcaption></figure></br>',
        sep = '')
  })
fscale <- 1.8
```


```{r functions, include=FALSE}
library(xtable)
dollarify <- function(){
    function(x) paste0("$",x,"$")
}
latex_matrix <- function(M){
  print(xtable(M, align=rep("",ncol(M)+1), digits=0), floating=FALSE, tabular.environment="pmatrix", include.rownames=FALSE, include.colnames=FALSE, hline.after=NULL, timestamp=NULL, comment=FALSE, print.results=FALSE)
  }
library(diagram) 
Bgraph <- function(fun_Mn, N, title=NA, blackpath=NULL, label_path=FALSE, labels_vertex=TRUE, USE.COLNAMES=FALSE, first_vertex=0, label_root="ø", only_end=FALSE, cex_vertex=1.5, labels_edges=TRUE, cex_edge=1.1, ...){
  Mn <- sapply(0:(N-1), function(n) fun_Mn(n))
  nvertices <- sapply(1:N, function(n) nrow(Mn[[n]])) # number of vertices per level
  elpos <- coordinates (c(nvertices, ncol(Mn[[N]])), ...) # positions of vertices
  left <- cumsum(nvertices)
  vertex <- function(n,k){ # n: level ; k: vertex at this level 
    left[n] + k 
  }
  # 
  l <- length(blackpath)
  blackpath <- c(blackpath, rep(0,N+1-l))
  blackpath <- blackpath +1  # NA useless but..
  #blackpath <- sapply(seq_along(blackpath), function(n) vertex(n, blackpath[n]))
  # construct connections matrix
  fromto <- NULL
  multiplicity <- NULL
  lcol <- lty <- lwd <- NULL
  # connections from level n=0
  current <- 1 
  for(i in which(Mn[[1]][1,]>0)){
    goto <- vertex(1, i)
    fromto <- rbind(fromto, c(current,goto))
    multiplicity <- c(multiplicity, Mn[[1]][1,i])
    lcol <- rbind(lcol, 
                  ifelse(i==blackpath[1], "blue", "gray")
    )
    lty <- rbind(lty, 
                 ifelse(i==blackpath[1], "solid", "solid")
    )
    lwd <- rbind(lwd, 
                 ifelse(i==blackpath[1], 4, 2)
    )
  }
  # connections from level n
  for(n in 1:(N-1)){
    for(i in 1:nrow(Mn[[n+1]])){
      current <- vertex(n,i)
      path_done <- FALSE
      for(k in which(Mn[[n+1]][i,]>0)){
        goto <- vertex(n+1, k)
        fromto <- rbind(fromto, c(current,goto))
        multiplicity <- c(multiplicity, Mn[[n+1]][i,k])
        s <- which.max(Mn[[n+1]][i,]>0)-1
        lcol <- rbind(lcol, 
                      #ifelse(k==s+blackpath[n], "blue", "gray")
                      ifelse(all(c(i,k)==blackpath[n:(n+1)]), "blue", "gray")
        )
        lty <- rbind(lty, 
                     ifelse(all(c(i,k)==blackpath[n:(n+1)]), "solid", "solid")
        )
        lwd <- rbind(lwd, 
                     ifelse(all(c(i,k)==blackpath[n:(n+1)]), 4, 2)
        )
      }
    }
  }
  nr <- nrow(fromto)
  if(labels_edges) labs_edges <- unlist( by(fromto[,1], fromto[,1], FUN=function(x) 1:length(x)) ) - 1
  arrpos <- matrix(ncol = 2, nrow = nr)
  # START PLOT 
  openplotmat(main=title)
  for (i in 1:nr){ # draw and store the arrows
    if(multiplicity[i]==1){
      arrpos[i, ] <- straightarrow (to = elpos[fromto[i, 2], ],
                                    from = elpos[fromto[i, 1], ],
                                    arr.pos = 0.5, arr.length = 0, 
                                    lcol=lcol[i], lty=lty[i], lwd=lwd[i])
    }
    if(multiplicity[i]==2){
      curvedarrow (to = elpos[fromto[i, 2], ],
                   from = elpos[fromto[i, 1], ],
                   arr.pos = 0.5, arr.length = 0, 
                   lcol=lcol[i], lty=lty[i], lwd=lwd[i],
                   curve=-0.05)
      arrpos[i, ] <- curvedarrow (to = elpos[fromto[i, 2], ],
                                  from = elpos[fromto[i, 1], ],
                                  arr.pos = 0.5, arr.length =0, 
                                  lcol=lcol[i], lty=lty[i], lwd=lwd[i],
                                  curve=0.05)
      #       straightarrow (to = elpos[fromto[i, 2], ],
      #                      from = elpos[fromto[i, 1], ],
      #                      arr.pos = 0.3, arr.length = 1, 
      #                       lwd=0)
      #       arrpos[i, ] <- straightarrow (to = elpos[fromto[i, 2], ],
      #                                     from = elpos[fromto[i, 1], ],
      #                                     arr.pos = 0.7, arr.length = 1, 
      #                                     lcol=lcol[i], lty=lty[i], lwd=lwd[i])
    }
    # labels on edges 
    if(labels_edges && !label_path){ # faire un black path only
      mid <- arrpos[i, ]
      textempty(mid+c(0,0), lab=labs_edges[i], cex=cex_edge)
      #textellipse(mid, 0.02, lab=labs_edges[i], cex = 1.1, lcol="white", shadow.size=0)
    }
    if(label_path){
      if(lcol[i]=="blue"){
        mid <- arrpos[i, ]
        textempty(mid+c(0,0), lab=labs_edges[i], cex=cex_edge)
      }
    }
  }
  if(labels_vertex){
    # root label 
    textellipse(elpos[1,], 0.01, 0.01, lab = label_root, box.col="white", shadow.size=0, lcol="white", cex=cex_vertex) 
    # vertices labels
    start <- ifelse(only_end, N, 1)
    for(n in start:N){ 
      for(i in 1:ncol(Mn[[n]])){
        lab <- as.character(ifelse(USE.COLNAMES, colnames(Mn[[n]])[i] , i-1+first_vertex))
        textempty(elpos[vertex(n,i),], lab = lab, cex=cex_vertex)
        #textellipse(elpos[vertex(n,i),], 0.03, 0.03, lab = lab, box.col = "white", shadow.size = 0, cex = 1.1)
        #textrect(elpos[vertex(n,i),], 0.03, 0.1, lab = lab, box.col = "white", shadow.size = 0, cex = 1.1)
      }
    }
  }
}
Pascal_Mn <- function (n) {
  M <- matrix(0, nrow = n + 1, ncol = n + 2)
  for (i in 1:(n + 1)) {
    M[i, ][c(i, i + 1)] <- 1
  }
  return(M)
}
```


A *Bratteli graph*, such as the *Pascal graph* shown below, is a graded graph whose edges only connect vertices from one level to vertices of the next level.

```{r, echo=FALSE, fig.width=fscale*3, fig.height=fscale*3,  fig.cap="Pascal graph"}
par(mar=c(1,1,0,1)/10)
Bgraph(Pascal_Mn, 3, USE.COLNAMES=FALSE, blackpath=c(1,2,3,3), first_vertex=1)
```

Such a graph is defined by a sequence of *incidence matrices* $M_n$. Denoting by $c_n$ the number of vertices at level $n$, the incidence  matrix $M_n$ is a $c_n \times c_{n+1}$ matrix showing all connections between level $n$ and level $n+1$. A "$0$" means there's no edge, a "$1$" means there's one edge, a "$2$" means there's a double edge, etc. The first three incidence matrices of the Pascal graph are 

```{r, echo=FALSE, results='asis'}
cat("$$", "M_0=", latex_matrix(Pascal_Mn(0)), ", \\, M_1=", latex_matrix(Pascal_Mn(1)), ", \\, M_2=", latex_matrix(Pascal_Mn(2)), ".$$")
```
 
and I get them with this function:
```{r}
Pascal_Mn <- function(n){
  M <- matrix(0, nrow=n+1, ncol=n+2)
  for(i in 1:(n+1)){
    M[i, ][c(i, i+1)] <- 1
  }
  return(M)
}
```


Given a function `fun_Mn` taking a nonnegative integer `n` as argument and returning an incidence matrix, such as the `Pascal_Mn` function, my `Bgraph` function draws the corresponding Bratteli graph from the root level to a desired level `N`. Its arguments are:
```{r}
formalArgs(Bgraph)
```

The figure above has been generated by this code:
```{r, eval=FALSE}
Bgraph(Pascal_Mn, 3, USE.COLNAMES=FALSE, blackpath=c(1,2,3,3), first_vertex=1)
```


### Odometers 

For an odometer, the incidence matrixes are full of "$1$": 

```{r}
Odometer_Mn <- function(sizes){
  sizes <- c(1,sizes)
  function(n){
    return(matrix(1, nrow=sizes[n+1], ncol=sizes[n+2]))
  }
}
```


```{r odometer, fig.width=fscale*3, fig.height=fscale*3,  fig.cap="(3,4,5)-ary odometer"}
par(mar=c(1,1,1,1)/10) 
fun_Mn <- Odometer_Mn(c(3,4,5))
Bgraph(fun_Mn, N=3, labels_vertex=TRUE, blackpath=c(2,1,2), label_path=TRUE)
```

This graph is related to [Cantor expansions](http://stla.github.io/stlapblog/posts/Greedy.html). For the previous example, the paths starting from the root level and going to the third level provide a representation of the Cartesian product  $\{0,1,2\}\times\{0,1,2,3\}\times\{0,1,2,3,4\}$. 

### Homogeneous trees 

A homogeneous tree is a Bratteli graph. I use a trick to generate the incidence matrices, [the same I already used before](http://stla.github.io/stlapblog/posts/KantorovichWithR.html).

```{r}
Tree_Mn <- function(sizes){
  function(n){
    if(n==0) return(matrix(1, ncol=sizes[1]))
    unname(t(model.matrix(~0+gl(prod(sizes[1:n]),sizes[n+1])))[,])
  }
}
```

As for the odometer, the paths of the tree provide a representation of a Cartesian producct, but in less compact form:

```{r tree, fig.width=fscale*3, fig.height=fscale*3,  fig.cap="(3,4,5)-ary tree"}
par(mar=c(1,1,1,1)/10) 
fun_Mn <- Tree_Mn(c(3,4,5))
Bgraph(fun_Mn, N=3, labels_vertex=FALSE, labels_edges=FALSE, blackpath=c(2,8,44))
```

### Conversion to `tikZ` 

........

